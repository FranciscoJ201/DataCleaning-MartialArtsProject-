#NORMALIZING POSE ESTIMATION OUTPUTS USING INTRINSIC OUTPUTS OF CAMERA


#The purpose of this script should be to convert a 2d Json to its 
# correct corresponding real world 2d points based on the translation and rotation vectors 
#that are constructed by the intrinsic calibration script
import cv2
import numpy as np
import json
import os

def load_calibration_data(calib_file_path):
    calib_file = f'{calib_file_path}.json'
    """
    Loads the Camera Matrix (K) and Distortion Coefficients (D) from the JSON file
    generated by intrinsic.py.
    """
    if not os.path.exists(calib_file):
        raise FileNotFoundError(f"Calibration file not found: {calib_file}")
    
    with open(calib_file, 'r') as f:
        data = json.load(f)

    # Ensure keys exist and convert lists back to numpy arrays
    K = np.array(data.get("camera_matrix"))
    D = np.array(data.get("distortion_coefficients"))
    
    if K is None or D is None:
        raise ValueError("JSON file is missing 'camera_matrix' or 'distortion_coefficients' keys.")
        
    return K, D

def undistort_pose_data(calibration_file, pose_data_file, output_file):
    """
    Loads 2D keypoints from pose estimation, corrects them for lens distortion 
    using the intrinsic parameters, and saves the new, normalized coordinates.

    Args:
        calibration_file (str): Path to the JSON file from intrinsic_calb().
        pose_data_file (str): Path to the JSON file from poseestimate().
        output_file (str): Path to save the new undistorted keypoints.
    """
    
    try:
        K, D = load_calibration_data(calibration_file)
        print("Successfully loaded Camera Matrix and Distortion Coefficients.")
    except Exception as e:
        print(f"Error loading calibration data: {e}")
        return

    if not os.path.exists(pose_data_file):
        print(f"Error: Pose data file not found: {pose_data_file}")
        return

    with open(pose_data_file, 'r') as f:
        all_detections = json.load(f)

    undistorted_detections = []
    
    # Process each detected person's keypoints
    for record in all_detections:
        keypoints_raw = record.get("keypoints_xyz", [])
        
        if not keypoints_raw:
            undistorted_detections.append(record)
            continue
            
        # 1. Prepare data for OpenCV
        # Extract only the (x, y) coordinates. 
        # The keypoints are [[x1, y1, c1], [x2, y2, c2], ...] where c is confidence or pseudo-z.
        points_2d = np.array([kp[:2] for kp in keypoints_raw], dtype=np.float32)

        # Reshape to (N, 1, 2) which is the format cv2.undistortPoints expects
        points_2d = points_2d.reshape(-1, 1, 2)
        
        # 2. Undistort the points
        # This converts distorted pixel coordinates to normalized, undistorted coordinates.
        # The resulting coordinates (x', y') are what the point would look like 
        # on an image plane in a perfectly pinhole camera model.
        # This is ideal for 3D reconstruction.
        undistorted_norm = cv2.undistortPoints(points_2d, K, D, P=None, R=None)
        
        # Reshape back to (N, 2)
        undistorted_norm = undistorted_norm.reshape(-1, 2)

        # 3. Recombine with original confidence/pseudo-z value
        undistorted_keypoints = []
        for i in range(len(keypoints_raw)):
            # Original keypoint: [x_distorted, y_distorted, confidence/z]
            # Undistorted keypoint: [x_norm, y_norm, confidence/z]
            
            # Use the normalized coordinates (x_norm, y_norm)
            x_norm = float(undistorted_norm[i, 0])
            y_norm = float(undistorted_norm[i, 1])
            
            # Retain the confidence/z-value from the original data
            conf = float(keypoints_raw[i][2])
            
            undistorted_keypoints.append([x_norm, y_norm, conf])
            
        # Update the record with the new coordinates
        new_record = record.copy()
        new_record["keypoints_undistorted_normalized"] = undistorted_keypoints
        undistorted_detections.append(new_record)
        
    # 4. Save the results
    with open(output_file, 'w') as f:
        json.dump(undistorted_detections, f, indent=4) 
    
    print(f"\nUndistortion complete. Saved {len(undistorted_detections)} records to {output_file}")
    print("\nNext Step: These normalized keypoints are now ready for 3D reconstruction/triangulation.")


